
<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Heftruck Schade-Inspector (AI‑ready)</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --muted: #6b7280;
      --accent: #22d3ee;
      --good: #10b981;
      --warn: #f59e0b;
      --bad: #ef4444;
      --text: #e5e7eb;
    }
    html, body {
      margin: 0; padding: 0; background: var(--bg); color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      height: 100%; overflow-x: hidden;
    }
    header {
      padding: 16px 20px; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: linear-gradient(180deg, #0f172a 0%, rgba(15,23,42,0.8) 100%);
      backdrop-filter: blur(6px); z-index: 10;
    }
    h1 { margin: 0; font-size: 20px; font-weight: 700; letter-spacing: 0.2px; }
    .sub { color: var(--muted); font-size: 12px; margin-top: 4px; }
    main { display: grid; gap: 16px; padding: 16px; grid-template-columns: 1fr; }
    @media (min-width: 980px) { main { grid-template-columns: 3fr 2fr; } }
    .stage {
      background: #0b1021; border: 1px solid #1f2937; border-radius: 14px; overflow: hidden; position: relative; min-height: 320px;
    }
    .video-wrap { position: relative; width: 100%; height: 100%; aspect-ratio: 16/9; background: #000; }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; }
    .overlay { pointer-events: none; }
    .badge {
      position: absolute; top: 10px; left: 10px; background: rgba(17,24,39,0.8); border: 1px solid #374151; padding: 8px 10px;
      border-radius: 10px; font-size: 12px; display: flex; gap: 8px; align-items: center;
    }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: var(--good); display: inline-block; }
    .sidebar {
      background: var(--panel); border: 1px solid #1f2937; border-radius: 14px; padding: 14px; display: grid; gap: 14px; height: fit-content;
    }
    .section { border: 1px dashed #374151; border-radius: 12px; padding: 12px; }
    .row { display: grid; gap: 8px; }
    .row.cols { grid-template-columns: 1fr 1fr; }
    label { font-size: 12px; color: var(--muted); }
    input[type="text"], input[type="number"], input[type="range"], select {
      width: 100%; background: #0b1021; color: var(--text); border: 1px solid #374151; padding: 8px 10px; border-radius: 10px;
      outline: none;
    }
    input[type="file"] { color: var(--text); font-size: 12px; }
    button {
      background: #0b1021; color: var(--text); border: 1px solid #374151; padding: 10px 12px; border-radius: 10px; cursor: pointer;
      transition: transform .06s ease, border-color .2s ease, background .2s ease;
    }
    button:hover { border-color: #475569; }
    button:active { transform: scale(0.98); }
    .btn-primary { background: linear-gradient(180deg, #0ea5e9, #0284c7); border: none; }
    .btn-danger { background: linear-gradient(180deg, #ef4444, #b91c1c); border: none; }
    .btn-success { background: linear-gradient(180deg, #10b981, #059669); border: none; }
    .btn-muted { opacity: .9; }
    .legend { display: flex; gap: 10px; align-items: center; font-size: 12px; color: var(--muted); flex-wrap: wrap; }
    .pill { border: 1px solid #374151; border-radius: 999px; padding: 2px 8px; }
    .sev-none { color: var(--good); }
    .sev-small { color: #93c5fd; }
    .sev-mid { color: var(--warn); }
    .sev-large { color: var(--bad); }
    .footer { color: var(--muted); font-size: 12px; }
    .hidden { display: none !important; }
    .status {
      display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;
    }
    .status div { background: #0b1021; border: 1px solid #1f2937; border-radius: 10px; padding: 8px; }
    .status b { color: var(--text); }
    .pointer-tip { position: absolute; background: rgba(239, 68, 68, 0.92); width: 10px; height: 10px; border-radius: 999px; box-shadow: 0 0 0 2px rgba(239,68,68,0.35); }
    .toast {
      position: fixed; bottom: 16px; right: 16px; background: rgba(17,24,39,0.95); border: 1px solid #374151; padding: 10px 12px; border-radius: 12px;
      font-size: 13px; z-index: 50;
    }
    .kbd {
      display: inline-block; border: 1px solid #475569; border-bottom-width: 3px; border-radius: 6px; padding: 1px 6px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Heftruck Schade‑Inspector <span class="sub">— live camera, AI‑ready, werkt ook in demo‑modus</span></h1>
  </header>

  <main>
    <section class="stage">
      <div class="video-wrap">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay" class="overlay"></canvas>
        <div class="badge" id="badge">
          <span class="dot" id="dot"></span>
          <span id="statusText">Camera niet gestart</span>
        </div>
      </div>
    </section>

    <aside class="sidebar">
      <div class="section">
        <div class="row cols">
          <button id="btnStart" class="btn-primary">Camera starten</button>
          <button id="btnStop" class="btn-danger">Camera stoppen</button>
        </div>
        <div class="row cols" style="margin-top:8px;">
          <button id="btnFlip" class="btn-muted">Wissel camera</button>
          <button id="btnSnap" class="btn-success">Snapshot + annotaties</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <label for="fileInput">Test met afbeelding (in plaats van camera)</label>
          <input id="fileInput" type="file" accept="image/*" />
        </div>
      </div>

      <div class="section">
        <div class="row">
          <label><b>Modus</b></label>
          <div class="legend">
            <label><input type="radio" name="mode" value="demo" checked /> Demo/Heuristiek</label>
            <label><input type="radio" name="mode" value="onnx" /> ONNX (eigen model‑URL’s)</label>
          </div>
        </div>

        <div class="row" id="onnxBlock" class="hidden" style="display:none;">
          <label for="forkliftModelUrl">Forklift detectie‑model URL (.onnx)</label>
          <input type="text" id="forkliftModelUrl" placeholder="https://.../forklift-detector.onnx" />
          <label for="damageModelUrl">Schade segmentatie‑model URL (.onnx, optioneel)</label>
          <input type="text" id="damageModelUrl" placeholder="https://.../damage-seg.onnx" />
          <button id="btnLoadModels">Modellen laden (beta)</button>
          <small class="sub">
            Opmerking: client‑side ONNX vereist modellen die op 1x3x640x640 (of vergelijkbaar) werken.
            Deze demo bevat <u>geen</u> standaardmodel; koppel je eigen (YOLO/seg) export.
          </small>
        </div>

        <div class="row">
          <label for="sens">Gevoeligheid schade (lager = strenger): <b id="sensVal">0.22</b></label>
          <input id="sens" type="range" min="0.05" max="0.9" step="0.01" value="0.22" />
        </div>
        <div class="row">
          <label for="minSpot">Min. pixels per schade‑spot: <b id="minSpotVal">60</b></label>
          <input id="minSpot" type="range" min="20" max="200" step="5" value="60" />
        </div>
        <div class="row">
          <label for="redGate">Forklift (rood)‑drempel: <b id="redGateVal">55</b></label>
          <input id="redGate" type="range" min="20" max="120" step="1" value="55" />
        </div>
        <div class="row">
          <label for="fps">Analyse‑FPS: <b id="fpsVal">5</b></label>
          <input id="fps" type="range" min="1" max="15" step="1" value="5" />
        </div>
      </div>

      <div class="section">
        <div class="status">
          <div><b>Forklift:</b> <span id="forkliftStatus">niet gedetecteerd</span></div>
          <div><b>Schadespots:</b> <span id="spotCount">0</span></div>
          <div><b>ROI:</b> <span id="roiInfo">0 × 0</span></div>
          <div><b>Ernst:</b> <span id="severityText" class="sev-none">geen</span></div>
        </div>
      </div>

      <div class="section footer">
        <div class="legend" style="margin-bottom:6px;">
          <span class="pill">Pointer = rood cirkeltje</span>
          <span class="pill sev-none">geen</span>
          <span class="pill sev-small">klein</span>
          <span class="pill sev-mid">middel</span>
          <span class="pill sev-large">groot</span>
        </div>
        <div>
          Tip: iPhone/iPad Safari vereist een tik op <span class="kbd">Camera starten</span> en gebruikt <em>playsinline</em> om fullscreen te voorkomen.
        </div>
      </div>
    </aside>
  </main>

  <div class="toast hidden" id="toast"></div>

  <!-- Optional: ONNX Runtime Web (voor toekomstige AI‑modellen) -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

  <script>
  // ====== Utility ======
  const $ = (id) => document.getElementById(id);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // DOM refs
  const video = $("video");
  const overlay = $("overlay");
  const ctx = overlay.getContext("2d");
  const statusText = $("statusText");
  const dot = $("dot");
  const btnStart = $("btnStart");
  const btnStop = $("btnStop");
  const btnFlip = $("btnFlip");
  const btnSnap = $("btnSnap");
  const fileInput = $("fileInput");
  const forkliftStatus = $("forkliftStatus");
  const spotCountEl = $("spotCount");
  const severityEl = $("severityText");
  const roiInfo = $("roiInfo");
  const toast = $("toast");
  const sens = $("sens"), sensVal = $("sensVal");
  const redGate = $("redGate"), redGateVal = $("redGateVal");
  const minSpot = $("minSpot"), minSpotVal = $("minSpotVal");
  const fps = $("fps"), fpsVal = $("fpsVal");

  // Mode
  const modeRadios = document.querySelectorAll('input[name="mode"]');
  const onnxBlock = $("onnxBlock");
  const forkliftModelUrl = $("forkliftModelUrl");
  const damageModelUrl = $("damageModelUrl");
  const btnLoadModels = $("btnLoadModels");

  // State
  let currStream = null;
  let facingMode = "environment"; // 'user'|'environment'
  let running = false;
  let analyserTimer = null;
  let lastFrameW = 0, lastFrameH = 0;
  let useOnnx = false;
  let onnxForkliftSession = null;
  let onnxDamageSession = null;

  // ====== Camera handling ======
  async function startCamera() {
    stopCamera();
    try {
      currStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = currStream;
      await video.play();
      running = true;
      statusText.textContent = "Camera actief";
      dot.style.background = "var(--good)";
      resizeCanvas();
      scheduleAnalyser();
    } catch (e) {
      running = false;
      statusText.textContent = "Geen toegang tot camera";
      dot.style.background = "var(--bad)";
      console.error(e);
      showToast("Toegang tot camera geweigerd of niet beschikbaar.");
    }
  }

  function stopCamera() {
    if (analyserTimer) {
      clearInterval(analyserTimer);
      analyserTimer = null;
    }
    running = false;
    if (video.srcObject) {
      video.pause();
      video.srcObject.getTracks().forEach(t => t.stop());
      video.srcObject = null;
    }
    statusText.textContent = "Camera gestopt";
    dot.style.background = "var(--bad)";
    ctx.clearRect(0, 0, overlay.width, overlay.height);
  }

  function resizeCanvas() {
    const rect = video.getBoundingClientRect();
    overlay.width = rect.width;
    overlay.height = rect.height;
  }

  window.addEventListener("resize", resizeCanvas);
  video.addEventListener("loadedmetadata", resizeCanvas);

  // ====== Demo/Heuristic pipeline ======
  /**
   * Vind een globale rode ROI (benadering van Linde‑rood) om de heftruck te lokaliseren.
   * Returnt {x,y,w,h, ratio} in canvas‑coördinaten, of null.
   */
  function findRedROI(imageData, redGateValue) {
    const { data, width, height } = imageData;
    let minX = width, minY = height, maxX = 0, maxY = 0, count = 0;
    for (let y = 0; y < height; y += 2) {
      for (let x = 0; x < width; x += 2) {
        const i = (y * width + x) * 4;
        const r = data[i], g = data[i+1], b = data[i+2];
        // eenvoudige rood‑heuristiek: r is duidelijk hoger dan g en b
        if (r - Math.max(g, b) > redGateValue && r > 120) {
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
          count++;
        }
      }
    }
    if (count < 200) return null;
    const w = clamp(maxX - minX, 10, width);
    const h = clamp(maxY - minY, 10, height);
    const areaRatio = (w * h) / (width * height);
    if (areaRatio < 0.02) return null; // te klein om een heftruck te zijn
    return { x: minX, y: minY, w, h, ratio: areaRatio };
  }

  /**
   * Schat schade‑spots binnen ROI m.b.v. eenvoudige gradiënt‑sterkte (Sobel‑achtig).
   * Returnt {centers: [{x,y,size}], damagePixels: number}
   */
  function detectDamageSpots(imageData, roi, sensitivity, minPixelsPerSpot) {
    const { data, width, height } = imageData;
    const x0 = Math.max(0, roi.x|0), y0 = Math.max(0, roi.y|0);
    const x1 = Math.min(width, (roi.x + roi.w)|0), y1 = Math.min(height, (roi.y + roi.h)|0);

    // Gradiënt magnitude (snelle benadering zonder volledige Sobel kernels)
    const grad = new Uint16Array(width * height);
    for (let y = y0+1; y < y1-1; y+=1) {
      for (let x = x0+1; x < x1-1; x+=1) {
        const i = (y * width + x) * 4;
        // luminantie
        const lum = (r,g,b)=>(0.299*r + 0.587*g + 0.114*b)|0;
        const L = lum(data[i], data[i+1], data[i+2]);
        const Lx = lum(data[i+4], data[i+5], data[i+6]) - lum(data[i-4], data[i-3], data[i-2]);
        const Ly = lum(data[i + 4*width], data[i + 4*width + 1], data[i + 4*width + 2]) -
                   lum(data[i - 4*width], data[i - 4*width + 1], data[i - 4*width + 2]);
        const gmag = Math.abs(Lx) + Math.abs(Ly);
        grad[y * width + x] = gmag;
      }
    }

    // Threshold op basis van gevoeligheid (sensitivity in [0.05..0.9])
    // Adaptive drempel: neem P‑tile benadering via sampling
    const samples = [];
    for (let y = y0; y < y1; y += 8) {
      for (let x = x0; x < x1; x += 8) samples.push(grad[y*width + x]);
    }
    samples.sort((a,b)=>a-b);
    const idx = Math.floor(samples.length * (1 - sensitivity));
    const thr = samples[Math.max(0, Math.min(samples.length-1, idx))] || 45;

    // Vind cellen met veel hoge gradiënt -> potentiële schadespots
    const cell = 18; // celgrootte (px)
    const centers = [];
    let damagePixels = 0;
    for (let cy = y0; cy < y1; cy += cell) {
      for (let cx = x0; cx < x1; cx += cell) {
        let cnt = 0;
        let sumx = 0, sumy = 0;
        for (let y = cy; y < Math.min(cy+cell, y1); y++) {
          for (let x = cx; x < Math.min(cx+cell, x1); x++) {
            if (grad[y*width + x] > thr) {
              cnt++; sumx += x; sumy += y;
            }
          }
        }
        if (cnt >= minPixelsPerSpot) {
          const cxn = (sumx / cnt)|0;
          const cyn = (sumy / cnt)|0;
          centers.push({ x: cxn, y: cyn, size: Math.sqrt(cnt) });
          damagePixels += cnt;
        }
      }
    }

    // Deduplicate nabijgelegen centers
    const dedup = [];
    const minDist = 24;
    centers.forEach(c => {
      let ok = true;
      for (const d of dedup) {
        const dx = d.x - c.x, dy = d.y - c.y;
        if (dx*dx + dy*dy < minDist*minDist) { ok = false; break; }
      }
      if (ok) dedup.push(c);
    });

    return { centers: dedup, damagePixels };
  }

  function computeSeverity(damagePixels, roi) {
    const area = Math.max(1, roi.w * roi.h);
    const ratio = (damagePixels / area) * 100; // %
    let label = "geen", cls = "sev-none";
    if (ratio > 0.0 && ratio <= 0.5) { label = "klein"; cls = "sev-small"; }
    else if (ratio > 0.5 && ratio <= 1.5) { label = "middel"; cls = "sev-mid"; }
    else if (ratio > 1.5) { label = "groot"; cls = "sev-large"; }
    return { ratio, label, cls };
  }

  function drawOverlay(roi, centers, severity) {
    const w = overlay.width, h = overlay.height;
    ctx.clearRect(0,0,w,h);

    if (roi) {
      ctx.strokeStyle = "rgba(56,189,248,0.9)";
      ctx.lineWidth = 2;
      ctx.setLineDash([8,4]);
      ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);
      ctx.setLineDash([]);
    }

    // pointers
    centers.forEach(c => {
      ctx.beginPath();
      ctx.arc(c.x, c.y, 6, 0, Math.PI*2);
      ctx.fillStyle = "rgba(239,68,68,0.92)";
      ctx.fill();
      ctx.closePath();
      // faint ring
      ctx.beginPath();
      ctx.arc(c.x, c.y, 9, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(239,68,68,0.35)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.closePath();
    });

    // severity label
    if (roi) {
      const pad = 8;
      const x = roi.x + pad, y = Math.max(20, roi.y + pad);
      const text = `Ernst: ${severity.label}`;
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system";
      const tw = ctx.measureText(text).width;
      ctx.fillStyle = "rgba(17,24,39,0.8)";
      ctx.fillRect(x-6, y-16, tw+12, 20);
      ctx.strokeStyle = "rgba(55,65,81,1)";
      ctx.lineWidth = 1;
      ctx.strokeRect(x-6, y-16, tw+12, 20);
      ctx.fillStyle = severity.cls === "sev-large" ? "#ef4444" :
                      severity.cls === "sev-mid" ? "#f59e0b" :
                      severity.cls === "sev-small" ? "#93c5fd" : "#10b981";
      ctx.fillText(text, x, y);
    }
  }

  // ====== ONNX placeholder (beta) ======
  async function loadOnnxModels() {
    if (!forkliftModelUrl.value) {
      showToast("Geef een Forklift detectie‑model URL op (.onnx)");
      return;
    }
    try {
      // WebGPU kan sneller zijn, maar niet overal beschikbaar
      const options = { executionProviders: ["webgpu", "wasm"] };
      onnxForkliftSession = await ort.InferenceSession.create(forkliftModelUrl.value, options);
      showToast("Forklift‑model geladen.");
      if (damageModelUrl.value) {
        onnxDamageSession = await ort.InferenceSession.create(damageModelUrl.value, options);
        showToast("Schade‑model geladen.");
      } else {
        onnxDamageSession = null;
      }
    } catch (e) {
      console.error(e);
      showToast("Laden ONNX‑modellen mislukt. Controleer de URL’s en CORS.");
    }
  }

  // Deze functie is een placeholder; echte model‑pre/post‑processing is model‑specifiek
  async function runOnnx(imageBitmap) {
    // Voorbeeld: resize naar 640x640, normaliseer, tensor maken
    const size = 640;
    const off = new OffscreenCanvas(size, size);
    const octx = off.getContext("2d");
    octx.drawImage(imageBitmap, 0, 0, size, size);
    const imgData = octx.getImageData(0, 0, size, size);
    const { data } = imgData;
    const float = new Float32Array(1 * 3 * size * size);
    let p = 0;
    for (let i = 0; i < data.length; i += 4) {
      float[p++] = data[i] / 255;     // R
    }
    for (let i = 0; i < data.length; i += 4) {
      float[p++] = data[i+1] / 255;   // G
    }
    for (let i = 0; i < data.length; i += 4) {
      float[p++] = data[i+2] / 255;   // B
    }
    const input = new ort.Tensor("float32", float, [1,3,size,size]);

    // LET OP: de volgende stap is model‑afhankelijk en dient aangepast te worden
    // Vooralsnog returnen we null zodat de demo‑heuristiek gebruikt kan worden als fallback
    return null;
  }

  // ====== Main analyser loop ======
  function scheduleAnalyser() {
    if (analyserTimer) clearInterval(analyserTimer);
    const interval = 1000 / parseInt(fps.value || "5", 10);
    analyserTimer = setInterval(analyseFrame, interval);
  }

  async function analyseFrame() {
    if (!running && !fileImageBitmap) return;

    const w = overlay.clientWidth, h = overlay.clientHeight;
    if (w < 2 || h < 2) return;
    if (w !== overlay.width || h !== overlay.height) {
      overlay.width = w; overlay.height = h;
    }

    let bitmap = null;
    if (fileImageBitmap) {
      bitmap = fileImageBitmap;
    } else if (video.videoWidth > 0) {
      bitmap = await createImageBitmap(video);
    } else {
      return;
    }

    // teken naar overlay context om aan imageData te kunnen komen
    ctx.drawImage(bitmap, 0, 0, overlay.width, overlay.height);
    const frame = ctx.getImageData(0, 0, overlay.width, overlay.height);

    let roi = null, centers = [], damagePixels = 0;

    if (useOnnx && onnxForkliftSession) {
      // Placeholder: ONNX pad (model‑specifieke implementatie vereist)
      const res = await runOnnx(bitmap);
      if (res && res.roi) {
        roi = res.roi;
        centers = res.centers || [];
        damagePixels = res.damagePixels || 0;
      } else {
        // Fallback op demo‑heuristiek
        roi = findRedROI(frame, parseInt(redGate.value,10));
        if (roi) {
          const dmg = detectDamageSpots(frame, roi, parseFloat(sens.value), parseInt(minSpot.value,10));
          centers = dmg.centers; damagePixels = dmg.damagePixels;
        }
      }
    } else {
      // Demo/Heuristiek pad
      roi = findRedROI(frame, parseInt(redGate.value,10));
      if (roi) {
        const dmg = detectDamageSpots(frame, roi, parseFloat(sens.value), parseInt(minSpot.value,10));
        centers = dmg.centers; damagePixels = dmg.damagePixels;
      }
    }

    // Update UI + overlay
    if (!roi) {
      forkliftStatus.textContent = "niet gedetecteerd";
      severityEl.textContent = "geen";
      severityEl.className = "sev-none";
      spotCountEl.textContent = "0";
      roiInfo.textContent = "0 × 0";
      ctx.clearRect(0,0,overlay.width, overlay.height);
    } else {
      forkliftStatus.textContent = "gedetecteerd";
      roiInfo.textContent = `${roi.w} × ${roi.h}`;
      spotCountEl.textContent = centers.length.toString();
      const sev = computeSeverity(damagePixels, roi);
      severityEl.textContent = sev.label;
      severityEl.className = sev.cls;
      drawOverlay(roi, centers, sev);
    }

    if (!fileImageBitmap) {
      // niets
    }
  }

  // ====== File input handling ======
  let fileImageBitmap = null;
  fileInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      stopCamera();
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.src = url;
      await img.decode();
      fileImageBitmap = await createImageBitmap(img);
      statusText.textContent = "Afbeelding geladen";
      dot.style.background = "var(--good)";
      running = true; // gebruik analyser ook voor still image
      scheduleAnalyser();
    } catch (err) {
      console.error(err);
      showToast("Afbeelding laden mislukt");
    }
  });

  // ====== UI Events ======
  btnStart.addEventListener("click", startCamera);
  btnStop.addEventListener("click", () => { fileImageBitmap = null; stopCamera(); });
  btnFlip.addEventListener("click", async () => {
    facingMode = facingMode === "environment" ? "user" : "environment";
    if (running && !fileImageBitmap) await startCamera();
  });
  btnSnap.addEventListener("click", () => {
    const a = document.createElement("a");
    a.download = `heftruck-schade-${Date.now()}.png`;
    a.href = overlay.toDataURL("image/png");
    a.click();
  });

  sens.addEventListener("input", ()=>{ sensVal.textContent = parseFloat(sens.value).toFixed(2); });
  redGate.addEventListener("input", ()=>{ redGateVal.textContent = parseInt(redGate.value,10); });
  minSpot.addEventListener("input", ()=>{ minSpotVal.textContent = parseInt(minSpot.value,10); });
  fps.addEventListener("input", ()=>{ fpsVal.textContent = parseInt(fps.value,10); scheduleAnalyser(); });

  modeRadios.forEach(r => r.addEventListener("change", () => {
    useOnnx = document.querySelector('input[name="mode"]:checked').value === "onnx";
    onnxBlock.style.display = useOnnx ? "block" : "none";
    showToast(useOnnx ? "ONNX‑modus (beta). Koppel je modellen." : "Demo/Heuristiek geactiveerd.");
  }));

  btnLoadModels.addEventListener("click", loadOnnxModels);

  // ====== Toast ======
  let toastTimer = null;
  function showToast(msg) {
    toast.textContent = msg;
    toast.classList.remove("hidden");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toast.classList.add("hidden"), 3500);
  }

  // Auto‑init: op iOS moet de gebruiker eerst op "Camera starten" tikken
  dot.style.background = "var(--bad)";
  </script>
</body>
</html>
